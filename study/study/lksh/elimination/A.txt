Во-первых, давайте сразу разобьем наш граф на компоненты связности и решим эту задачу независимо для каждой компоненты.
Когда найдем ответ для каждой компоненты, просто возьмем максимум среди них. Алгоритм нахождения всех компонент связанностей:
Давайте сделаем серию запусков обходов в глубину, при этом если после окончания очередного поиска мы еще не посетили все вершины графа,
то только что обойденный граф является отдельной компонентой связности. При этом после того, как мы обошли все вершины,
надо также отметить последний посещенный граф как еще одну компоненту.
Здесь и далее я рассматриваю граф как одну из компонент большого графа, чтобы было проще работать.

Отлично, теперь мы имеем связный граф.
Давайте выделим и сожмем все компоненты сильной связности графа - таким образом у нас останется ориентированный связный граф без циклов.
Алгоритм сжатия компонент сильной связности: Опять же, совершим серию обходов в глубину,
при этом для каждой вершины запомним время выхода и время входа в нее.
Время входа - это когда мы приступили к обходу вершины и всех ее детей,
а время выхода - это когда мы обошли всех ее детей и заканчиваем обход вершины.
Короче говоря, необходимо совершить топологическую сортировку в графе.
То есть расположить вершины в порядке убывания времени выхода.
А потом в порядке топологической сортировки пойдем по обратному графу
(где все ориентированные ребра из A в B заменены на из B в A) и просто найдем все
компоненты связности по алгоритму, описанному в первом параграфе.
Таким образом мы получим конденсированный граф. На нем уже можно работать.


Давайте запустим топологическую сортировку на этом графе и пойдем по вершинам
в обратном порядке. В каждой вершине будем запоминать какое-то значение - максимум
из всех сыновей вершины + кол-во монет в вершине. Если сыновей нет, то просто указываем
кол-во монет. Таким образом ответом будет максимумом по массиву с числами, т.к. начинать он может с разных вершин.

Ответ действительно верный, ведь если Гоблин попал в цикл в графе, то он может собрать
все монетки на всех вершинах и выйти с любой вершины. Таким образом я доказал корректность
рассуждений о конденсации графа. Далее, т.к. после сжатия граф стал ацикличным,
Гоблину будет выгоднее начать из вершины, в которую не входят ребра, ведь если ребра входят,
он может набрать еще больше монет начав с той вершины (будем думать, что отрицательного кол-ва монет не бывает).
Таким образом можно просто пойти ‘с конца’, то есть в обратном порядке пути Гоблина.
Если Гоблин встретит развилку, он выберет тот путь, на котором будет больше монет, а т.к. мы шли с конца,
мы знаем, где будет пройти выгоднее. В случае, если вершин без входящих ребер будет больше, чем 1,
мы просто можем  взять максимум со всех таких вершин и не ошибемся, ведь ответ точно находится в какой-то из данных вершин.
